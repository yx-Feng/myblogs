### 1. 什么是Redis，Redis能做什么

Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此**读写速度非常快**，常用于**缓存，消息队列、分布式锁等场景**。

### 2. 数据类型

String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)

Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流）

- String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。
- List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。
- Hash 类型：缓存对象、购物车等。
- Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。
- Zset 类型：排序场景，比如排行榜、电话和姓名排序等。

### 3. 为什么用 Redis 作为 MySQL 的缓存？

主要是因为 **Redis**具备「高性能」和「高并发」两种特性。

- **高性能**：用户第一次访问 MySQL 中的某些数据，这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。

- **高并发**：Redis 每秒钟能够承受的请求是远远大于直接访问 MySQL 的。单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍。

### 4. Redis 如何实现数据不丢失？

Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。

Redis 共有三种数据持久化的方式：

- **AOF 日志**：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；
  
  - （因为 AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢。）
  
  - AOF通过记录每一个写操作，确保几乎所有操作都能被恢复。即使Redis崩溃，也能恢复到最近的状态。

- **RDB 快照**：将某一时刻的内存数据，以二进制的方式写入磁盘
  
  - 如果Redis在生成RDB快照的间隔内发生崩溃，所有在最后一次快照后写入的数据都会丢失。
  
  - RDB文件是二进制格式，通常比AOF文件小，适合于存储和备份。在系统重启时，RDB文件加载速度相对较快。

- **混合持久化方式**：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；

### 5. Redis常见指令

- **字符串操作**：Redis的基础数据类型，用于存储简单的键值对。
  
  - 常用命令：`SET`、`GET`、`INCR`。
  - 例如：`SET key value`将值存储到指定键中，`INCR`用于整数递增。

- **哈希操作**：适合存储类似对象的结构，可以包含多个字段和值。
  
  - 常用命令：`HSET`、`HGET`、`HGETALL`。
  - 例如：`HSET user name "Alice"`存储用户对象的字段信息，`HGETALL`可以一次性获取所有字段。

- **列表操作**：双向链表，用于消息队列、任务列表等场景。
  
  - 常用命令：`LPUSH`、`RPUSH`、`LPOP`、`LRANGE`。
  - 例如：`LPUSH`从左插入元素，`LRANGE`可以获取列表范围。

- **集合操作**：无序集合，自动去重，适合快速判断成员关系。
  
  - 常用命令：`SADD`、`SREM`、`SMEMBERS`。
  - 例如：`SADD myset "apple"`添加元素，`SISMEMBER`可以判断元素是否在集合内。

- **有序集合操作**：有序集合，根据分数排序，可以实现排行榜等功能。
  
  - 常用命令：`ZADD`、`ZRANGE`、`ZREVRANGE`。
  - 例如：`ZADD leaderboard 100 "Alice"`用于添加带分数的元素，`ZRANGE`按分数排序获取元素。

### 6. redis持久化策略

**①RDB (Redis DataBase Snapshot)**

快照持久化，在一定的时间间隔内，将Redis内存中的数据以二进制的形式保存到硬盘上。这个二进制文件就是一个快照。

=> 占用空间小，适合做备份和灾难恢复

=> 缺点：由于是定时触发，所以在Redis崩溃时，可能会丢失最近一次快照之后的数据

**②AOF (Append Only File)**

追加文件：将Redis服务器执行的每一条写命令都记录到一个文本文件中，这个文本文件就是一个追加文件。

=> 数据安全性高，每一条写操作都被记录，最多只会丢失几毫秒的数据

=> 因为每次写操作都需要被记录，可能会导致Redis写性能稍有下降

**③AOF与RDB混合**

### 7. redis为什么快呢

**基于内存操作**：Redis 将所有数据存储在内存中，内存的读写速度通常远远高于磁盘。

**单线程模型**：Redis 使用单线程模型，避免了多线程环境下的线程切换、竞争等开销。单线程能够保证操作的原子性和一致性，减少锁的使用和死锁的风险，提升了执行效率。

**非阻塞 I/O 多路复用**：允许服务器在单个线程内高效管理多个客户端连接，从而提升并发处理能力。

- 在传统阻塞 I/O 模型中，系统会阻塞在某个 I/O 操作（如读取数据）上，直到操作完成才会继续处理其他任务。在非阻塞 I/O 中，程序不会因为等待 I/O 操作完成而暂停，而是立即返回去检查下一个任务。非阻塞 I/O 可以让进程在没有数据时继续其他操作，避免了等待 I/O 完成而浪费的 CPU 资源。

- 多路复用是指通过一个机制同时监视多个 I/O 通道，检测出哪些通道处于“准备就绪”的状态并进行处理。

### 8. 你用redis做了些什么

导航网站

- 使用redis缓存验证码。key为 `前缀captcha:codes: + uuid`，value是生成的验证码字符串。
- redis+Lua脚本实现对特定接口的限流。key为`自定义前缀（rate:limiter:）+类名+方法名+ IP/用户ID`，value为请求次数。

火车购票系统

- 分布式锁：解决车票超卖的问题
  
  - key：前缀LOCK_CONFIRM_ORDER - 日期 - 车次
  
  - value：用于标识持有锁的客户端
    
    ```
    lock = redissonClient.getLock(lockKey);
    boolean tryLock = lock.tryLock(0, TimeUnit.SECONDS);
    // 释放锁
    lock.unlock();
    ```

### 9. Redis 的 Lua 脚本原理

Redis 提供了对 Lua 脚本的支持，可以通过 `EVAL` 或 `EVALSHA` 命令执行 Lua 脚本。Lua 脚本的执行是在 Redis 服务器端进行的，因此具有原子性和高效性。

- Redis 在执行 Lua 脚本期间，其他命令不会被执行，直到当前脚本执行完毕。这保证了脚本执行中的操作不会被其他 Redis 客户端操作中断。
- 因为 Redis 本身是单线程的，所以即使是多个脚本的并发执行，Redis 也会逐个处理它们。

### 10. Redis 单线程的理解

- **单线程模型**：Redis 使用一个主线程来处理所有的客户端请求。每个客户端请求（无论是读取、写入数据，还是执行其他操作）都由 Redis 主线程逐一处理。在请求到达时，Redis 会将请求放入一个队列，然后逐个从队列中取出并处理请求。

- **高效的 I/O 多路复用**：Redis 使用的是 **非阻塞 I/O**，通过 I/O 多路复用技术来高效地处理多个客户端连接。这意味着 Redis 能够在同一个线程中同时处理大量的连接请求，不需要为每个连接都创建一个线程。

**好处**

- 减少上下文切换开销：在多线程模型下，操作系统需要频繁进行线程上下文切换，这会带来额外的开销。

- 简化开发与维护：多线程编程会面临许多复杂的并发问题，如数据竞态、死锁、锁的管理等。通过使用单线程，Redis 避免了这些复杂性，并且逻辑更加简单，易于维护。

### 11. redis分布式锁原理，具体细节，可重入怎么实现

**加锁**

- 命令格式：`SET key value NX PX ttl`。
  
  - `NX`：表示“只有在键不存在时才执行操作”，保证加锁的原子性。
  - `PX ttl`：设置锁的自动过期时间，避免因客户端崩溃导致锁永久存在。
  - 锁的 `value` 通常是一个唯一标识（如 UUID），用于区分不同客户端持有的锁。只有持有该唯一标识的客户端才能释放锁，确保解锁的正确性。

- 如果 `SET` 返回成功，表示加锁成功；否则加锁失败（其他客户端已持有锁）。

**解锁**

- 客户端释放锁时，需确认自己持有锁（通过唯一标识 `value`），以避免误解锁其他客户端的锁。

**自动过期**：

- 设置锁的过期时间 (`ttl`) 是为了防止客户端崩溃后，锁无法被释放。
- 锁过期后，其他客户端可以重新获取

### 12. Redis作为缓存，会出现哪些问题，并讲讲解决方法

**① 缓存穿透**：客户端请求的数据在缓存和数据库中都不存在。

- 解决方法：
  
  - 缓存空结果：如果查询结果为空（如数据库中也不存在），将空结果（如 `null` 或特定值）存入缓存，并设置一个较短的过期时间。

**② 缓存击穿**：指某个热点数据在缓存中失效的瞬间，大量并发请求同时访问该数据，导致大量请求涌向数据库。

- 解决办法：
  
  - 设置热点数据永不过期。
  
  - 使用分布式锁来确保只有一个请求能去加载数据并更新缓存，其余请求等待。

**③ 缓存雪崩**：指大量缓存同时失效，导致大量请求同时访问数据库，可能导致数据库崩溃。

- 解决办法：
  
  - 缓存过期时间随机化：在设置缓存过期时间时，添加一个随机值，避免所有缓存同时失效。
    
    ```
    redis.set(key, value, baseTTL + random.nextInt(maxOffset));
    ```
  
  - 使用限流措施控制访问数据库的请求数量，例如漏桶算法或令牌桶算法。

**④ 热点 Key 问题**：某些热点 Key 被频繁访问，可能导致 Redis 单节点压力过大，甚至出现性能瓶颈。

- 解决办法：
  
  - 分片缓存：将热点数据拆分成多个子 Key，分散到不同的 Redis 节点。例如：当用户请求自己的信息时，可以通过不同的子 `Key` 来访问各个部分的缓存，如通过 `user:1:info` 获取个人基本信息，`user:1:orders` 获取订单信息。不同的子 `Key` 可能存储在不同的 Redis 节点上，从而避免了单个节点的压力过大。
  
  - 多级缓存：在本地缓存（如 Caffeine）和 Redis 之间分担热点数据的访问压力。
  
  - 请求合并：通过批量处理或队列机制，将对同一 Key 的访问合并成一次请求。

**⑤ 缓存与数据库双写不一致**：由于 Redis 是内存数据库，数据会被频繁地缓存到 Redis 中以提高读取性能。当 MySQL 中的数据发生变化时，缓存的 Redis 数据可能没有及时更新，导致数据不一致。

- 解决办法：
  
  - 写时更新（Write-through cache）：当更新数据时，首先更新缓存，然后再更新数据库。这样可以保证缓存和数据库之间的一致性，但会导致写入延迟增加。
  
  - 延迟双删策略：在更新数据库前先删除缓存。更新数据库后再延迟删除缓存，确保一致性。

### 13. Redis 过期淘汰策略

Redis 的过期淘汰策略是指在**内存达到上限**时，如何处理存储的数据。它主要包括两方面：**过期键的删除机制**和**内存淘汰策略**。

**过期键的删除机制**

- 定期删除：Redis 每隔一定时间（默认 100ms）随机检查一部分设置了过期时间的键。如果发现这些键已经过期，就将其删除。

- 惰性删除：当访问一个键时，Redis 会检查该键是否已过期。如果键已过期，则在访问时才会被删除。

- 主动删除：当 Redis 的内存不足时，会主动尝试清理过期键来释放空间。

**内存淘汰策略**

- noeviction：默认策略。不淘汰任何键，直接拒绝写入新数据并返回错误。适合只读场景或不希望丢失数据的情况。

- allkeys-lru：淘汰所有键中最少使用的键（Least Recently Used, LRU）。适合缓存场景，确保最近访问的数据尽量保留。

- allkeys-random：随机淘汰所有键。

- allkeys-lfu：淘汰所有键中访问频率最低的键（Least Frequently Used, LFU）。

- volatile-lru：在设置了过期时间的键中，淘汰最少使用的键。如果没有设置过期时间的键，则拒绝写入。

- volatile-random：在设置了过期时间的键中，随机淘汰键。

- volatile-lfu：在设置了过期时间的键中，淘汰访问频率最低的键。

### 14.
