### 1. 什么是Redis

Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此**读写速度非常快**，常用于**缓存，消息队列、分布式锁等场景**。

### 2. 数据类型

String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)

Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流）

- String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。
- List 类型的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。
- Hash 类型：缓存对象、购物车等。
- Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。
- Zset 类型：排序场景，比如排行榜、电话和姓名排序等。

### 3. 为什么用 Redis 作为 MySQL 的缓存？

主要是因为 **Redis**具备「高性能」和「高并发」两种特性。

- **高性能**：用户第一次访问 MySQL 中的某些数据，这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。

- **高并发**：Redis 每秒钟能够承受的请求是远远大于直接访问 MySQL 的。单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍。

### 4. Redis 如何实现数据不丢失？

Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。

Redis 共有三种数据持久化的方式：

- **AOF 日志**：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；
  
  - （因为 AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢。）
  
  - AOF通过记录每一个写操作，确保几乎所有操作都能被恢复。即使Redis崩溃，也能恢复到最近的状态。

- **RDB 快照**：将某一时刻的内存数据，以二进制的方式写入磁盘
  
  - 如果Redis在生成RDB快照的间隔内发生崩溃，所有在最后一次快照后写入的数据都会丢失。
  
  - RDB文件是二进制格式，通常比AOF文件小，适合于存储和备份。在系统重启时，RDB文件加载速度相对较快。

- **混合持久化方式**：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；

### 5. Redis常见指令

- **字符串操作**：Redis的基础数据类型，用于存储简单的键值对。
  
  - 常用命令：`SET`、`GET`、`INCR`。
  - 例如：`SET key value`将值存储到指定键中，`INCR`用于整数递增。

- **哈希操作**：适合存储类似对象的结构，可以包含多个字段和值。
  
  - 常用命令：`HSET`、`HGET`、`HGETALL`。
  - 例如：`HSET user name "Alice"`存储用户对象的字段信息，`HGETALL`可以一次性获取所有字段。

- **列表操作**：双向链表，用于消息队列、任务列表等场景。
  
  - 常用命令：`LPUSH`、`RPUSH`、`LPOP`、`LRANGE`。
  - 例如：`LPUSH`从左插入元素，`LRANGE`可以获取列表范围。

- **集合操作**：无序集合，自动去重，适合快速判断成员关系。
  
  - 常用命令：`SADD`、`SREM`、`SMEMBERS`。
  - 例如：`SADD myset "apple"`添加元素，`SISMEMBER`可以判断元素是否在集合内。

- **有序集合操作**：有序集合，根据分数排序，可以实现排行榜等功能。
  
  - 常用命令：`ZADD`、`ZRANGE`、`ZREVRANGE`。
  - 例如：`ZADD leaderboard 100 "Alice"`用于添加带分数的元素，`ZRANGE`按分数排序获取元素。

### 6. redis持久化策略

**①RDB (Redis DataBase Snapshot)**

快照持久化，在一定的时间间隔内，将Redis内存中的数据以二进制的形式保存到硬盘上。这个二进制文件就是一个快照。

=> 占用空间小，适合做备份和灾难恢复

=> 缺点：由于是定时触发，所以在Redis崩溃时，可能会丢失最近一次快照之后的数据

**②AOF (Append Only File)**

追加文件：将Redis服务器执行的每一条写命令都记录到一个文本文件中，这个文本文件就是一个追加文件。

=> 数据安全性高，每一条写操作都被记录，最多只会丢失几毫秒的数据

=> 因为每次写操作都需要被记录，可能会导致Redis写性能稍有下降

**③AOF与RDB混合**

### 7. redis为什么快呢

**基于内存操作**：Redis 将所有数据存储在内存中，内存的读写速度通常远远高于磁盘。

**单线程模型**：Redis 使用单线程模型，避免了多线程环境下的线程切换、竞争等开销。单线程能够保证操作的原子性和一致性，减少锁的使用和死锁的风险，提升了执行效率。

**非阻塞 I/O 多路复用**：允许服务器在单个线程内高效管理多个客户端连接，从而提升并发处理能力。

- 在传统阻塞 I/O 模型中，系统会阻塞在某个 I/O 操作（如读取数据）上，直到操作完成才会继续处理其他任务。在非阻塞 I/O 中，程序不会因为等待 I/O 操作完成而暂停，而是立即返回去检查下一个任务。非阻塞 I/O 可以让进程在没有数据时继续其他操作，避免了等待 I/O 完成而浪费的 CPU 资源。

- 多路复用是指通过一个机制同时监视多个 I/O 通道，检测出哪些通道处于“准备就绪”的状态并进行处理。

### 8. 你用redis做了些什么

导航网站

- 使用redis缓存验证码。key为 `前缀captcha:codes: + uuid`，value是生成的验证码字符串。
- redis+Lua脚本实现对特定接口的限流。key为`自定义前缀（rate:limiter:）+类名+方法名+ IP/用户ID`，value为请求次数。

火车购票系统

- 分布式锁：解决车票超卖的问题
  
  - key：前缀LOCK_CONFIRM_ORDER - 日期 - 车次
  
  - value：用于标识持有锁的客户端
    
    ```
    lock = redissonClient.getLock(lockKey);
    boolean tryLock = lock.tryLock(0, TimeUnit.SECONDS);
    // 释放锁
    lock.unlock();
    ```
