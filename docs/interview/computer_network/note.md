### 1. Http和Https的区别

**Http**：数据在客户端和服务器之间以**明文**传输，容易受到中间人的攻击和篡改数据。没有加密和解密过程，性能稍高。

**Https**：使用**SSL**(Secure Sockets Layer，安全套接层，已舍弃)或**TLS**(Transport Layer Security, 传输层安全性协议)协议对传输数据进行**加密**。由于需要进行加密和解密，性能上会稍微有些损耗。

加密过程：客户端发起请求，服务器返回包含公钥的数字证书，客户端验证证书是否合法后，用公钥加密生成的对称密钥并发送给服务器，服务器用私钥解密得到对称密钥，之后，双方用该对称密钥对数据进行加密传输。



http和https使用的**默认端口**也不一样，http是80，https是443。

### 2. 解释一下HTTP无状态

每个 HTTP 请求都是独立的，与之前或之后的请求没有直接关系，服务器不会自动记录或保存客户端的状态。

**如何实现状态管理？**

- **Session**：服务器为每个客户端创建一个会话，用Session ID来跟踪客户端的状态。

- **Token**：状态信息以加密形式存储在客户端（通常存储在客户端的本地存储LocalStorage或会话存储SessionStorage中），客户端每次请求时携带 Token（需要开发者手动添加到请求中，通常放在 HTTP 请求头的 `Authorization` 字段中，也可以放在 URL 参数或请求体中）。

- **Cookie**：是一种存储在客户端（浏览器）上的小型文本数据，用于保存用户状态信息，它会随着每次 HTTP 请求**自动**发送到服务器。

### 3. OSI七层模型、TCP/IP四层模型，做了哪些优化

网络协议是指在网络中实现通信的一组规则和约定，它定义了如何在不同设备之间传输数据。

网络协议通常按分层模型组织，典型模型包括：

**OSI七层模型**：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

- 物理层：在物理介质（如电缆、光纤、无线）上传输原始比特流（0和1）。

- 数据链路层：将比特组织成帧，提供链路的可靠传输。处理差错检测（CRC校验）、流量控制（如滑动窗口）和介质访问控制（如MAC地址）。

- 网络层：通过IP地址实现跨网络的路由选择（路径规划），处理拥塞控制、分组分片与重组。

- 传输层：提供端到端的可靠或不可靠数据传输。分割数据段、处理流量控制（如TCP滑动窗口）和错误恢复。

- 会话层：管理通信会话的建立、维护和终止。处理会话同步（如断点续传）和权限控制。

- 表示层：负责数据格式转换、加密解密（如SSL/TSL）、压缩解压缩。

- 应用层：直接为用户应用程序提供服务（如网页浏览、文件传输），处理用户接口和应用协议。

**TCP/IP四层模型**：网络接口层、网络层、传输层、应用层

**优化**：TCP/IP模型将一些OSI模型中的层次进行了合并与简化，例如，去掉了会话层和表示层，将它们的功能直接集成在应用层中，简化了协议设计和实现，提高了模型的可操作性和效率。例如，将物理层和数据链路层合并为一个 网络接口层，简化了低层通信的实现，减少了复杂性。

### 4. 网络七层协议中，tcp属于哪层，http属于哪层

- **TCP（传输控制协议）** 属于 **传输层**（第4层）。传输层负责在两个节点之间提供可靠的传输服务，TCP就是一种面向连接、可靠的数据传输协议。

- **HTTP（超文本传输协议）** 属于 **应用层**（第7层）。应用层直接为用户提供服务，HTTP是用于在客户端和服务器之间传输超文本数据（如网页）的协议。

### 5. TCP和UDP区别

**UDP**

- 无连接的非可靠传输层协议
- 向上提供一条不可靠的逻辑信道
- 面向报文流

**TCP**

- 面向连接的传输控制协议
- 向上提供一条全双工的可靠逻辑信道
- 面向字节流

### 6. 私有地址

- A类：10.0.0.0 - 10.255.255.255
- B类：172.16.0.0 - 172.31.255.255
- C类：192.168.0.0 - 192.168.255.255

### 7. 在浏览器输入URL后的过程（网页提交之后发生了什么事）

1. **DNS查询**：查看浏览器缓存-->操作系统缓存-->查找本地host文件，看是否有该域名的IP地址映射。
   
   => 如果本地没有缓存，浏览器会向DNS服务器发送一个DNS查询请求，以获取域名对应的IP地址。

2. **TCP连接**：浏览器要和该IP建立TCP连接。

3. **客户端向服务端发送HTTP请求**

4. **服务器处理HTTP请求并将响应数据返回给客户端**

5. **浏览器解析并render页面**

6. **TCP连接断开**

### 8. http域名怎么映射到IP的

HTTP 域名映射到 IP 地址的过程主要依赖于 **DNS（域名系统）**。域名解析是将人类可读的域名（如 `www.example.com`）转换为机器可读的 IP 地址（如 `192.168.1.1`）的过程。

① DNS 查询过程

当你在浏览器中输入一个网址时，浏览器会触发一系列的 DNS 查询，最终得到与域名关联的 IP 地址。

a. 本地缓存检查：当你访问一个网站时，操作系统首先会检查本地 DNS 缓存，查看是否已经缓存了该域名对应的 IP 地址。如果缓存中有有效记录，浏览器就直接使用该 IP 地址，不再进行进一步查询。

b. 查询本地 DNS 服务器：如果本地没有缓存，操作系统会将域名解析请求发送给配置好的 **本地 DNS 服务器**。

c. 如果本地 DNS 服务器没有该域名的解析记录，它会向更高层次的 DNS 服务器查询。首先，它会查询 **根域名服务器**，根域名服务器存储着顶级域（如 `.com`, `.org`, `.net` 等）对应的权威 DNS 服务器的信息。根域名服务器会返回负责该域名的**顶级域名服务器**（例如，`.com` 域名的 TLD 服务器）。本地 DNS 服务器会向**该 TLD 服务器**发送查询请求。TLD 服务器会指向该域名的权威 DNS 服务器（通常是该网站的 DNS 提供商所提供的服务器）。权威 DNS 服务器存储了该域名及其子域名的完整解析记录。

d. 返回解析结果：权威 DNS 服务器会返回该域名对应的 IP 地址。

### 9. TCP连接的建立：3次握手

(1)客户端首先向服务端发送TCP连接请求报文段。报文段首部中同步位SYN=1，同时选一个初始序号seq=x。客户端进入SYN_SEND状态。

(2)服务器收到请求后，如果同意连接，则向客户机发送确认，SYN=1,ACK=1,确认号ack=x+1，选择一个初始序号seq=y。服务端进入SYN_RECEIVED状态。

(3)客户机收到确认报文段后，还要向服务器发送确认，seq=x+1，ack=y+1。此时客户端进入ESTABLISHED状态，服务端收到ACK报文后，也进入ESTABLISHED状态。

![55c436c21f7abb243f6954249065bf82081e49dd.png](assets/8260d30ef5a12a381407364674418520d00989df.png)

**为什么是三次握手？不是两次或四次？**

如果只有两次，也就是客户端发送一次连接请求，服务端发送确认。但是如果客户端没收到这条消息（中途丢了或者被网络阻塞了），服务端认为连接已建立，客户端认为没建立，服务端处于“半连接”状态，占用资源，容易收到SYN Flood攻击（DoS攻击的一种）。

我们考虑一个场景，客户端先发送了SYN(seq=90)报文，但是这个SYN报文被网络阻塞了，服务端并没有收到，接着客户端又重新向服务端建立连接，发送了SYN(sq=100)报文。一个「旧SYN报文」比「最新的SYN报文」早到达了服务端，那么此时服务端就会回一个SYN+AcK报文给客户端，此报文中的确认号是91(90+1)。客户端收到后，发现自己期望收到的确认号应该是100+1，而不是90+1，于是就会回RST报文。服务端收到RST报文后，就会释放连接。后续最新的SYN抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。可以看到，如果采用两次握手建立TCP连接的场景下，服务端在向客户端发送数据前，**并没有阻止掉历史连接**，导致服务端建立了一个历史连接，又白白发送了数据，浪费了服务端的资源。

**SYN Flood攻击**：攻击者伪造大量 IP 地址，不断向服务器发送 `SYN` 请求。服务器响应每个请求，等待客户端确认。由于源地址不存在，因此Server需要不断重发直至超时，会导致服务器不能处理新的正常连接请求了。

为什么不是四次握手？因为三次已经足够确认双方的状态了，多一次没必要，多了一次只是浪费资源、增加时延。

**如果第二次握手服务端没有接收到信息该怎么处理？**

超时重传，如果服务端多次重传后仍未收到客户端的确认信息，则会认为客户端未响应，从而终止连接请求，释放资源。

### 10. TCP连接的释放：4次挥手

因为 TCP 是**全双工**通信，双方都要各自关闭“发送”通道。每一方关闭时都需要一个 **FIN（finish）** 报文和一个 **ACK（确认）** 报文，所以一共需要 4 次。

下面以 **客户端主动断开连接** 为例（服务端也可以主动）：

(1)客户机打算关闭连接时，向服务器发送连接释放报文段。FIN=1,seq=u。

(2)服务器收到后发出确认，ACK=1, ack=u+1，seq=v。（表示“我知道你不发数据了”）

(3)若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，FIN=1，ACK=1,ack=u+1，seq=w。（表示“我也不发数据了”）

(4)客户机收到连接释放报文段后，必须发出确认，ACK=1，ack=w+1,seq=u+1，然后等待一段时间后，客户机才进入连接关闭状态。（表示“我知道你也不发了，咱彻底断了”）

![ecc9f81766dd5783f1277cbc9733eac6ae6dac81.png](assets/3dd31950379687e2b904e0aee9b11fb37ed3568a.png)

**第四次挥手客户端需要等多久？**

在 TCP 四次挥手的过程中，客户端在发送 `FIN` 并接收到服务端的 `ACK` 后，进入 **TIME_WAIT** 状态，需要等待一段时间（通常为 2 倍的报文最大生存时间，简称 2MSL，即 Maximum Segment Lifetime）再完全关闭连接。

### 11. 介绍一下TCP的全双工

**全双工通信**指的是连接的两方可以同时进行数据的 **发送** 和 **接收**，而不需要等待对方完成发送。

在 TCP 中，每一端都会维护一个**发送队列**和**接收队列**。

### 12. 介绍一下http包头

请求 => 请求行+请求头

响应=> 状态行+响应头

请求行：结构：`方法 请求路径 协议版本`  示例：`GET /index.html HTTP/1.1`

状态行（Status Line）：结构：`协议版本 状态码 状态描述` 示例：`HTTP/1.1 200 OK`

请求头：包含客户端发送给服务器的各种信息，常见字段包括：

- **`Host`**：请求的服务器域名。

- **`User-Agent`**：客户端的软件信息（例如浏览器类型）。

- **`Accept`**：客户端支持的内容类型（如 `text/html`, `application/json`）。

- **`Authorization`**：用于身份验证的凭证。

响应头：包含服务器返回给客户端的信息，常见字段包括：

- **`Content-Type`**：返回内容的类型（如 `text/html`）。

- **`Content-Length`**：响应体的大小（字节数）。

- **`Set-Cookie`**：设置客户端 Cookie 的信息。

- **`Cache-Control`**：控制缓存机制的指令。

### 13. CDN

CDN-Content Delivery Network 内容分发网络

**核心理念**：将内容缓存在终端用户附近。

**具体来说**，在用户访问相对集中的地区放置缓存服务器(CDN边缘节点)，当用户访问网站时，由距离最近的缓存服务器来响应用户请求。 

**使用CDN技术的好处**：加速了网站的访问。安全方面，内容进行分发后，源服务器的IP会被隐藏，受到攻击的概率会大幅下降。

### 14. 通俗易懂地介绍互联网、局域网、内网、外网

互联网：全世界的电脑和设备相互连接，让它们能够”相互聊天“ 或 "分享信息"。就像世界上的所有人都用同一个邮局发送信件。

局域网：一个“小型的网络”，通常用于一个公司、学校或家庭内部，连接一小部分设备，比如电脑、打印机等。就像一个家庭内部的“传话筒”，大家互相说话很方便，但不与外人联系。

内网：指在局域网中运行的一种私有网络，通常用于企业或机构内部的信息系统。内网资源对外部不可见，需要特定权限或安全通道（如 VPN）才能访问。**例子**：公司内部的办公系统（如 ERP、CRM）。学校的教务管理系统。

外网：指 “对外开放的网络”，就是互联网中大家都能访问的部分，用户可以通过外网与其他网络通信。**例子**：访问淘宝、刷抖音时用的就是外网。

### 15. WebSocket 与 HTTP 协议的区别

WebSocket 和 HTTP 都是基于 TCP 的应用层协议，但它们的设计目标和使用场景有所不同。

- **HTTP**
  
  - 一种**请求-响应**模式的通信协议，客户端发送请求，服务器返回响应。
  - 是一种**无状态**协议，通信完成后连接会关闭（除非使用 HTTP Keep-Alive）。

- **WebSocket**
  
  - 一种**全双工**通信协议，允许客户端和服务器之间同时进行双向通信。
  - 是一种**有状态**协议，建立连接后，连接会一直保持，直到客户端或服务器主动断开。

### 16. TCP拥塞控制

TCP 拥塞控制是 TCP 协议中用于防止网络拥塞、确保数据传输稳定性的核心机制。其核心思想是通过动态调整发送窗口大小，平衡网络负载与传输效率。

**四大经典算法**

**（1）慢启动（Slow Start）**

- **初始阶段**：发送窗口（Congestion Window, `cwnd`）从 1 个 MSS（最大段大小）开始。
- **指数增长**：每收到一个 ACK，`cwnd` 增加 1，直到达到阈值（`ssthresh`）或发生丢包。
- **触发条件**：连接建立后或超时重传后。

**（2）拥塞避免（Congestion Avoidance）**

- **线性增长**：当 `cwnd > ssthresh` 时，每轮 RTT（往返时间）`cwnd` 增加 1。
- **触发条件**：进入稳定传输阶段后。

**（3）快速重传（Fast Retransmit）**

- **检测丢包**：收到 3 个重复 ACK 时，认为某个数据包丢失。
- **立即重传**：无需等待超时，直接重传丢失的数据包。

**（4）快速恢复（Fast Recovery）**

- **调整策略**：
  1. `ssthresh` 减半。
  2. `cwnd` 设置为 `ssthresh + 3*MSS`（假设三个重复 ACK 对应三个已接收的包）。
  3. 进入拥塞避免阶段，而非慢启动。
