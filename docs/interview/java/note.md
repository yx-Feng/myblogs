### 1. 基本数据类型和引用数据类型有什么不同

基本数据类型：

- 直接存储在**栈内存**中，占用固定大小的内容空间

- 内存分配：静态分配、自动回收

引用数据类型：

- 对象存储在**堆内存**中，变量保存的是指向对象的引用（内存地址），这个引用存储在栈中

- 内存分配：动态分配，通常由 **JVM的垃圾回收机制** 管理，负责回收不再使用的对象。

### 2. Java了解哪些IO模型？

**①同步阻塞IO**

调用IO操作时，线程会被阻塞，直到有数据可以进行读写操作。

**②同步非阻塞IO**

调用read()或write()时，如果数据没有准备好，方法立即返回，不阻塞线程。

**③异步IO**

当应用程序发起 IO 请求时，不需要等待操作完成，而是立即返回，操作结果通过回调机制（Callback）通知应用程序。

### 3. Java集合用过哪些？哪些集合是线程安全的?

- List接口
  
  - ArrayList：基于数组，线程不安全
  
  - LinkedList：基于双向链表，线程不安全

- Set接口
  
  - HashSet：基于HashMap实现，线程不安全
  
  - TreeSet：基于红黑树实现，线程不安全

- Map接口
  
  - HashMap：基于哈希表，线程不安全
  
  - Hashtable：类似HashMap，但是所有方法都同步了，线程安全

### 4. 为什么要用动态性线程池

使用动态性线程池是为了**在任务量变化时灵活调整线程数量**，优化资源利用，通过复用线程，避免频繁创建和销毁线程，提高系统的效率和吞吐量。在高负载时，它能增加线程处理任务，低负载时则减少线程，节省资源。

### 5. hashmap和hashtable区别

`HashMap` 适合单线程或不需要线程安全的场景，性能较高；`Hashtable` 是线程安全的，但性能较低。

**HashMap**：**非线程安全**，它在多线程环境下不保证一致性，因此多个线程同时访问和修改 `HashMap` 可能导致数据不一致。

**Hashtable**：**线程安全**，内部对方法进行了同步处理（通过 `synchronized`），因此它在多线程环境中是安全的，但同步开销较大，性能较低。

（通过**同步机制**，可以确保在同一时间只有一个线程访问某一段代码或资源，其他线程必须等待该资源被释放后才能访问）

### 6. arraylist和linkedlist的区别

都是 Java 中常用的列表集合类

**ArrayList**：基于**动态数组**实现。它使用一个**连续的内存块**存储数据，当数组容量不足时，会自动扩容，增加新的空间。读取速度快，插入和删除元素慢。

**LinkedList**：基于**双向链表**实现，每个元素都存储有前后节点的引用（指针），从而支持双向遍历。**不需要连续的内存空间**。读取速度较慢，插入和删除速度快。

### 7. bean的生命周期

- 实例化 -> 当 Spring 容器启动并扫描到需要管理的 Bean 时，首先通过构造函数实例化 Bean 对象。
- 属性注入 -> Spring 容器为实例化的 Bean 注入它的依赖属性。
- 初始化前（`postProcessBeforeInitialization`） -> 在 Bean 初始化之前，Spring 允许开发者通过实现 `BeanPostProcessor` 接口的 `postProcessBeforeInitialization()` 方法，定义自定义逻辑。这个阶段可以对 Bean 进行一些修改或操作。
- 初始化
- 初始化后（`postProcessAfterInitialization`） -> 在 Bean 初始化完成后，Spring 再次调用 `BeanPostProcessor` 的 `postProcessAfterInitialization()` 方法，允许开发者在 Bean 准备好之后执行自定义逻辑或进一步处理 Bean。
- 使用 Bean -> Bean 准备完毕后，Spring 容器会将其交给应用程序使用。
- 销毁 -> 当 Spring 容器关闭时，或 Bean 的生命周期结束时，Spring 会对 Bean 进行销毁操作。

### 8. innodb有哪些日志

InnoDB 是 MySQL 默认的存储引擎

- **Redo Log - 重做日志**：保证数据的**持久性**，用于崩溃恢复。在事务提交后，InnoDB 会将对数据的更改记录到重做日志中，即使数据还没有真正写入磁盘。当系统崩溃后，可以通过重做日志恢复尚未写入磁盘的数据。

- **Undo Log - 撤销日志**：用于支持**事务回滚**和**MVCC（多版本并发控制）**。当事务修改数据时，InnoDB 会将旧版本的数据保存在撤销日志中。如果事务被回滚，可以通过撤销日志恢复原来的数据版本。同时，撤销日志也用于实现 MVCC，使得其他事务可以读取事务修改之前的数据版本。

- **bin log - 二进制日志**：记录所有对数据库产生变更的 SQL 语句，主要用于数据库恢复（恢复到某个时间点）和主从复制（将主数据库的更改复制到从数据库）。

### 9. mvcc是解决了哪些问题

**MVCC**（Multiversion Concurrency Control，多版本并发控制）

- **读写冲突**。在传统的**锁机制**中，读操作和写操作之间会发生冲突，例如，当一个事务正在写入数据时，另一个事务如果要读取同一数据，可能会被阻塞。MVCC 通过提供**数据快照（为每个事务提供不同版本的快照数据）**，让读操作无需等待写操作完成，从而避免了读写操作之间的冲突，提高并发性能。

- **脏读**：避免读取到其他事务未提交的数据。MVCC 为每个事务提供**一致的读视图**，即一个事务在执行过程中，总是能看到事务开始时的数据版本。避免一个事务在读操作中看到其他事务的未提交数据，解决了**脏读**的问题，保证了读操作的一致性。

- **幻读**：幻读是指在一个事务中执行相同的查询，可能会因为其他事务的插入导致结果集不一致。MVCC 通过管理事务的版本号，保证在同一个事务中，**读操作**看到的数据版本是固定的，不会因为其他事务的插入或修改而改变，解决了幻读问题。

### 10. 原子性和可见性是什么

**原子性**：是指一个操作是不可分割的，要么完整地执行完毕，要么不执行（在多线程环境下）。原子操作意味着在操作的过程中，任何其他线程都不能看到操作处于中间状态。

**可见性**：确保一个线程对共享变量的修改能够被其他线程立即看到。在多线程环境下，一个线程对某个变量的修改可能存储在其本地缓存中，而其他线程无法立即看到这个修改。

**为什么需要保证可见性，是什么问题导致的？**

为了确保一个线程对共享变量的修改能够被其他线程及时看到，避免因线程之间对共享数据的视图不一致而导致程序出现错误或不正确的行为。

### 11. 你所理解的AQS

AQS，全称AbstractQueueSynchronizer，抽象队列同步器，是一个抽象类，主要用来构建同步队列的同步器。

核心思想：AQS维护一个由线程组成的FIFO队列，当共享资源被占用时，其它线程都会被加入到这个队列中等待。当资源上的锁被释放时，AQS会唤醒队列中的线程，确保线程按顺序获取资源。

### 12. 布隆过滤器(Bloom Filter)

**布隆过滤器**（Bloom Filter）是一种高效的**空间复杂度**的数据结构，用于判断一个元素是否存在于一个集合中。

一个位数组，以及多个独立的哈希函数，如果想添加一个元素，首先会通过所有哈希函数计算该元素的哈希值，这些值对应的位置置为1。查询元素，同样使用哈希函数计算哈希值，所有位置的值为1，则表明该元素可能在集合中，有任何一个位置的值为0，则元素不在集合中。

**缺点**：①可能会误判某个元素存在 ②一但元素被添加到布隆过滤器中，无法删除（因为多个元素可能映射到同一位，删除操作会导致其他元素的状态被改变）。

**布隆过滤器如何提高容错能力？**

增大布隆过滤器的位数组、增加哈希函数的数量

### 13. java中的多线程，如何实现的

**继承 `Thread` 类**：重写 `run()` 方法，定义线程的行为。启动线程时，通过 `start()` 方法来启动。

**实现 `Runnable` 接口**：创建一个实现 `Runnable` 接口的类，重写 `run()` 方法。将 `Runnable` 实例传递给 `Thread` 对象，再调用 `start()` 方法启动。

**使用 `ExecutorService` 创建线程池**：`ExecutorService` 提供了创建和管理线程池的功能，常见线程池包括 `FixedThreadPool`、`CachedThreadPool` 等。通过线程池执行线程时，使用 `execute()` 或 `submit()` 方法提交任务。

### 14. 生产者和消费者，你会用什么同步机制

在生产者-消费者模型中，生产者负责生产数据，而消费者负责处理数据。由于生产者和消费者可能在不同的线程或进程中执行，因此需要使用同步机制来确保数据安全地在它们之间传递。

**① 阻塞队列（Blocking Queue）**

生产者在队列满时阻塞，消费者在队列为空时阻塞。

**② 信号量（Semaphore）**

信号量是一个计数器，用于控制访问特定资源的线程数量。

- 对于生产者-消费者问题，可以使用两个信号量：一个用于计数可用的缓冲区位置（空位计数），一个用于计数已填充的缓冲区数据（满位计数）。
- 生产者在添加数据前减少空位计数，消费者在取出数据前减少满位计数，从而协调生产和消费的速度。

**③ 互斥锁 + 条件变量**

通过锁保护共享资源，确保同一时刻只有一个线程可以访问共享资源。

条件变量允许线程在特定条件满足时通知其他线程继续工作。生产者会通知消费者数据已经准备好，消费者会等待该通知，反之亦然。

### 15. Java中的静态内部类

在Java中，静态内部类（Static Nested Class）是定义在另一个类内部的类，并使用 `static` 修饰。

静态内部类不依赖于外部类的实例。它可以在没有外部类对象的情况下被实例化。

将内部类放在外部类中可以更好地体现它们之间的关系（比如一个外部类Car和一个静态内部类Engine）。它使得相关类的逻辑更加紧密，便于管理和阅读。

```
public class OuterClass {
    private static String staticOuterField = "Outer static field";
    private String instanceOuterField = "Outer instance field";

    // 静态内部类
    public static class StaticNestedClass {
        public void display() {
            // 可以访问外部类的静态成员
            System.out.println(staticOuterField);
            // 无法直接访问外部类的非静态成员
            // System.out.println(instanceOuterField); // 编译错误
        }
    }

    public void createNested() {
        StaticNestedClass nested = new StaticNestedClass();
        nested.display();
    }
}

public class Main {
    public static void main(String[] args) {
        // 直接实例化静态内部类
        OuterClass.StaticNestedClass nestedClass = new OuterClass.StaticNestedClass();
        nestedClass.display();
    }
}
```

### 16. Java8有哪些新特性

**① Lambda表达式**

```
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.forEach(name -> System.out.println(name));
```

**② 接口可以包含默认实现的方法**

```
interface MyInterface {
    default void myDefaultMethod() {
        System.out.println("Default implementation");
    }
}

class MyClass implements MyInterface {}
```

**③ Stream API**

简化集合的操作，过滤操作如下：

```
List<String> filteredNames = names.stream()
    .filter(name -> name.startsWith("A"))
    .collect(Collectors.toList());
```

### 17.讲一下对 Java 锁的了解

Java 中的锁主要用于控制多个线程对共享资源的访问，确保线程安全。 

**基于锁的获取与释放方式**

- 隐式锁（内置锁）：通用synchronized关键字实现的一种线程同步机制。当一个线程进入被synchronized修饰的方法时，会自动获得对象级别的锁，退出该方法时则会自动释放这把锁。

- 显示锁（ReentrantLock、ReentrantReadWriteLock、StampedLock）：由 `java.util.concurrent.locks.Lock`接口及其诸多实现类提供的同步机制。相较于隐式锁，显式锁提供了更为多样化的锁操作选项，包括：支持线程在等待锁时可被中断、根据先后顺序分配锁资源的公平锁与非公平锁机制。

**基于对资源的访问权限**

- 独占锁：是一种同步机制，它确保在任一时刻，最多只有一个线程可以获得锁并对受保护的资源进行访问或修改。

- 共享锁：许多个线程同时读取共享资源，但不允许任何线程修改资源。

**基于锁的获取公平性**

- 公平锁：当多个线程尝试获取锁时，锁的分配遵循“先请求先服务”，这意味着等待时间最长的线程将优先获得锁，有效避免线程饥饿的问题。

- 非公平锁：当多个线程尝试获取锁时，锁的分配不遵循“先请求先服务”，而是允许任何等待锁的线程在锁被释放时尝试获取。在某些场景下可以提高系统的并发性能，因为它不强制线程排队等待。

**基于对共享资源的访问方式**

- 悲观锁：它假设在并发环境下，多个线程对共享资源的访问极有可能发生冲突，因此在访问资源之前，先尝试获取并锁定资源，直到该线程完成对资源的访问并释放锁，其他线程才能继续访问。

- 乐观锁：乐观锁假设在多线程环境中，冲突发生的可能性较小，因此在访问数据时不加锁，而是在操作结束时检查数据是否被其他线程修改过。

### 18. volatile关键字 的主要作用，以及它为什么线程不安全？

volatile关键字的作用就是保证共享变量的**可见性**，也就是说，一个线程读变量，总是能读到它在内存中的最新的值，也就是说不同线程看到的一个变量的值是相同的。

使用volatile保证线程安全，需要满足两个条件：①对变量的写操作不依赖于当前值 ②该变量没有包含在其它变量的不变式中

其他情况下volatile并不能保证线程安全问题，因为volatile并不能保证变量操作的原子性。

### 19. synchorized和volatile的区别

`synchronized`和`volatile`都是用来实现线程安全的关键字，但它们的功能和使用场景有所不同。

**synchronized**

- 用于对某个方法或代码块进行加锁，确保同一时间只有一个线程可以执行被锁的代码，从而实现互斥访问。

- 可保证可见性和原子性。

- 适合有复杂逻辑、需要多步操作的共享资源的访问保护。

**volatile**

- 保证变量的可见性，确保线程读取到的是最新的变量值，而非缓存值。

- 只能保证可见性，**不保证原子性**。例如，`count++`这种操作不能用`volatile`实现安全。
  
  - `count++`实际上包含了三个步骤：读取、修改、写入，这些操作并不是原子的。
  
  - 虽然`volatile`保证了`count`的可见性，但不能保证在多个线程并发执行时的正确性。

- 适合用于简单的状态标志，例如状态开关、标志变量等，不需要多步操作的共享数据。

### 20.  Java的设计模式有哪些

设计模式是指：面对同类软件工程设计问题，总结出来的设计经验，一种通用的解决方案

创建型模式：用于对象的创建，包括单例、工厂等模式

- 工厂方法

- 抽象工厂

- 单例

- 建造者

- 原型

结构型模式：用于描述对象之间的组合关系，包括代理、享元等模式

- 适配器

- 装饰器

- 代理

- 外观

- 桥接

- 组合

- 享元

行为型模式：用于描述对象之间的通信和责任分配，包括模板方法、观察者、责任链等模式

- 策略

- 模板方法

- 观察者

- 迭代子模式

- 责任链模式

- 命令模式

- 备忘录模式

- 状态模式

- 访问者模式

- 中介者模式

- 解释器模式

### 21. 面向过程和面向对象的区别

**面向过程**：以过程（即函数）为中心的编程方式，关注操作和步骤的顺序。将问题分解为一系列步骤或过程，逐步实现。

**面向对象**：以对象为中心的编程方式，通过封装、继承和多态等特性构建复杂系统。将问题分解为对象，每个对象具有状态（属性）和行为（方法）。

### 22. 重载和重写的区别

**重载**：在同一个类中，方法名称相同，但参数类型或参数个数不同。

**重写**：在子类中定义与父类方法同名、同参数的实例方法，以实现子类特定的功能。

### 23. 抽象类和接口的区别

**抽象类**：一种不能被实例化的类，允许包含抽象方法（没有实现的方法）和已实现的方法。通过 `extends` 关键字继承；一个类只能继承一个抽象类。

**接口**：一种纯抽象类，只能包含抽象方法（Java 8 后可以有默认方法和静态方法）。通过 `implements` 关键字实现；一个类可以实现多个接口。

### 24. 限流算法了解哪些？令牌桶和漏桶的区别

- 令牌桶（Token Bucket）
  
  - 令牌桶算法使用一个桶来存储令牌，桶的容量是固定的，桶中的令牌是按固定速率生成的。
  
  - 每当一个请求到达时，系统会检查桶中是否有令牌。如果有，就消耗一个令牌并处理该请求；如果没有，则请求被丢弃或限流。
  
  - 令牌的生成速率和桶的大小共同决定了系统的流量限制。
  
  - **突发流量**：可以处理突发请求。如果桶中有令牌，允许快速处理一批请求；如果桶空了，则请求将被限制。

- 漏桶（Leaky Bucket）
  
  - 漏桶算法把请求放入一个漏桶中，桶的大小是固定的。请求以固定速率从桶中流出。
  
  - 每当一个请求到达时，如果桶未满，就把请求放入桶中；如果桶已满，请求将被丢弃或限流。
  
  - 请求以恒定的速率被处理，从而保证了请求的流出速率是平稳的。
  
  - **稳定性**：即使请求到达的速率很快，系统也会以固定的速率处理请求，避免了瞬时的流量过大。

### 25. jvm的结构

Java虚拟机（JVM）是Java平台的核心部分，负责执行Java字节码并提供运行环境。JVM的结构可以分为多个主要组件，每个组件都有其特定的功能。

- **类加载子系统**（Class Loader Subsystem）：负责将Java类加载到内存中，并进行验证（验证字节码的合法性）、准备（分配内存并初始化类变量）和解析（将符号引用转换为直接引用）。

- **运行时数据区**（Runtime Data Area）：JVM在运行时会创建几个数据区来管理数据，这些数据区包括：
  
  - **方法区（Method Area）**：存放已加载类的信息、常量池、字段和方法数据等，所有线程共享。
  - **堆（Heap）**：用于存放对象实例和数组，是垃圾回收器的主要工作区域。所有线程共享堆。
  - **栈（Stack）**：每个线程都有自己的Java虚拟机栈，用于存储局部变量、操作数栈和方法调用的相关信息。栈帧的压入和弹出操作与方法调用和返回密切相关。
  - **程序计数器（Program Counter Register）**：每个线程都有一个程序计数器，用于记录当前线程所执行的字节码行号。
  - **本地方法栈（Native Method Stack）**：与Java栈类似，但用于存放本地方法的相关信息。

- **执行引擎**（Execution Engine）：负责执行JVM中的字节码。

- **垃圾回收器**（Garbage Collector）：自动管理内存，回收不再使用的对象，防止内存泄漏。

- **本地接口**（Native Interface）：与其他编程语言（如C/C++）的本地方法交互，提供与底层操作系统或硬件的接口。

### 26. 了解JVM调优吗

**堆内存设置**：通过 `-Xms` 和 `-Xmx` 参数设置堆的初始大小和最大大小

**选择合适的垃圾回收器**：Java 提供了多种垃圾回收器，可以根据应用特点选择适合的垃圾回收策略：

- **Serial GC**：单线程垃圾回收，适合单线程应用或小内存的环境。
- **Parallel GC**：多线程垃圾回收，适合多线程环境，追求高吞吐量。
- **CMS GC**（Concurrent Mark Sweep）：低延迟回收器，适合需要低延迟的应用。
- **G1 GC**（Garbage-First GC）：适合大内存、多 CPU 核心的应用环境，兼顾延迟和吞吐量，Java 9 之后推荐为默认 GC。

**编译优化**：调整 JIT（Just-In-Time） 编译的行为，例如 -XX:CompileThreshold 参数决定方法何时被编译成本地代码。当 JIT 编译器监测到某个方法被频繁调用时，便会将该方法的字节码编译成本地代码（机器代码），并将其缓存。此后每次调用这个方法时，JVM 直接执行已编译的机器码，不再解释字节码，从而提高执行速度。`-XX:CompileThreshold` 指定了方法被调用的次数阈值。

### 27. jvm的内存划分

Java 虚拟机（JVM）在运行时将内存划分为多个区域，每个区域有特定的用途。

- 程序计数器（Program Counter Register）：记录当前线程执行的字节码指令的地址或行号。

- 虚拟机栈（Java Virtual Machine Stack）：存储方法执行的相关信息，包括局部变量、操作数栈、方法出口等。

- 本地方法栈（Native Method Stack）：与虚拟机栈类似，但用于存放本地方法（如使用 JNI 调用的 C/C++ 代码）。

- 堆（Heap）：存储对象实例和数组，是垃圾回收的主要区域。

- 方法区（Method Area）：用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

- 运行时常量池（Runtime Constant Pool）：方法区的一部分，存放编译期间生成的字面量和符号引用。

- 前三个，每个线程都有独立的。后三个，所有线程都共享。

### 28. ArrayList和LinkedList

`ArrayList`和`LinkedList`都是用于存储元素的集合类，它们都实现了`List`接口，但在内部实现、性能和使用场景上存在显著差异。

- **ArrayList**：
  
  - 基于动态数组实现，底层使用数组来存储元素。
  - 随机访问元素的速度较快。

- **LinkedList**：
  
  - 基于双向链表实现，每个元素（节点）包含对前一个和后一个节点的引用。
  - 不需要连续的内存空间，适合频繁插入和删除操作。

### 29. Hashmap的底层数据结构

**数组 + 链表 + 红黑树**

`HashMap` 的底层首先是一个 **数组**，称为哈希桶。每个数组元素称为一个 **桶（bucket）**，用于存储键值对 (`Entry` 或 `Node` 对象)。

如果两个键计算出的哈希值相同（发生**哈希冲突**），`HashMap` 会在对应的桶位置上形成一个 **链表**。在较早的Java版本（如 Java 7），链表是解决哈希冲突的主要方式。当发生冲突时，新元素将追加在链表的尾部。

从 **Java 8** 开始，为了提高在大量哈希冲突时的性能，`HashMap` 引入了 **红黑树**。当链表长度超过一定阈值（默认是 8）时，链表会**转化为红黑树**，以提升查找效率。

红黑树是一种自平衡的二叉搜索树，保证了在最差情况下的时间复杂度为 `O(log n)`，从而避免链表过长带来的效率问题。 

### 30. 垃圾回收算法

**引用计数算法**：为每个对象维护一个引用计数器，记录有多少个引用指向该对象。当引用计数为零时，说明该对象不再被使用，可以被回收。

**标记-清除算法**（Mark-and-Sweep）：分为两个阶段：标记和清除。在标记阶段，从根对象开始，递归标记所有可达对象。标记完成后，清除未标记的对象。

**标记-整理算法**：标记阶段与标记-清除相同，但在清除阶段将存活对象移动到一端，然后清除其他部分的内存。=> 减少了内存碎片，提升了内存使用效率。

**复制算法：** 复制算法将内存分为两个大小相等的区域，称为 **From 区域** 和 **To 区域**。每次仅使用其中一个区域（例如，From 区域）来分配对象，回收过程如下：

- 分配内存：对象会不断被分配到 From 区域，当 From 区域被占满时，开始垃圾回收。

- 垃圾回收：从根对象（如栈上引用的对象）开始扫描，递归标记所有可达对象。将每个存活对象从 From 区域复制到 To 区域，并更新相关引用以指向新位置。

- 切换角色：复制完成后，交换 From 和 To 区域的角色。此时 To 区域成为新的 From 区域，而原来的 From 区域则被清空，可用于下一次分配。

**分代收集算法：** 分代收集算法基于对象生命周期的长短，划分出新生代、老年代等区域，并使用不同的回收策略 。新生代使用复制算法，因为新生代对象大多生命周期短；老年代使用标记-整理或标记-清除，避免内存碎片化。

### 31.Object类有哪些方法

- `equals(Object obj)`：用于比较两个对象是否相等。默认实现是比较对象的引用地址，通常需要在子类中重写以实现内容比较。

- `hashCode()`：返回对象的哈希值，配合 `equals` 方法使用，通常需要重写来确保相同的对象具有相同的哈希值。

- `toString()`：返回对象的字符串表示，默认是类名加上对象的哈希码，通常会在子类中重写以提供更有意义的描述。

- `getClass()`：返回对象的运行时类（`Class` 对象），用于获取类的元信息。

- `clone()`：用于创建对象的浅拷贝。`Object` 类默认实现了浅拷贝机制，需要实现 `Cloneable` 接口来调用此方法。（对象的浅拷贝（Shallow Copy）是指复制一个对象时，只复制对象的基本字段和引用类型字段的引用，而不复制引用类型字段所指向的实际对象。）

### 32. equals方法和==方法有什么不同

`==` 用于比较基本数据类型的值或两个对象引用是否指向同一内存位置。

`equals()` 方法用于比较对象的**内容**是否相同。

### 33.了解过 CurrentHashMap 吗

与普通的 `HashMap` 不同，通过细粒度的锁（分段锁）来避免整个 map 被锁住，从而减少了锁竞争，提高了并发性能。在 `ConcurrentHashMap` 中，内部结构被分为多个段，每个段都有独立的锁。当线程需要访问不同段的数据时，它们可以并发进行，而不互相干扰。

### 34. 介绍一下hashmap，它是不安全的，怎么办

`HashMap`底层是基于哈希表实现的，利用哈希函数将键映射到对应的索引位置上。

**非线程安全**：在多线程环境中，`HashMap`的并发操作（如`put()`、`get()`）可能导致不一致的数据状态，甚至导致死循环等问题。

如何解决 `HashMap` 的线程安全问题

- 使用 `Hashtable`：`Hashtable`是`HashMap`的线程安全版本，每个方法都使用了`synchronized`关键字。

- 使用 `ConcurrentHashMap`：`ConcurrentHashMap`是一个线程安全的哈希表，是`HashMap`的一个改进版本，专门为多线程环境设计。`ConcurrentHashMap`采用分段锁机制，将数据分为多个段，每个段可以独立加锁，减少了锁竞争，从而提高了并发性能。

### 35. 手写一个单例模式

单例模式（Singleton Pattern）是一种创建型设计模式，确保在程序运行期间，一个类只能有一个实例，并且提供一个全局访问点。

```
public class Singleton {
    private static volatile Singleton instance;

    // 私有化构造函数，防止外部实例化
    private Singleton() {}
    
    // 提供一个全局访问点，获取单例对象
    public static Singleton getInstance() {
        if(instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 36.线程池怎么创建，线程池可以用来干嘛，你用过的是哪种线程池

在 Java 中，线程池是通过 `Executor` 框架来管理的。要创建线程池，通常使用 `Executors` 工厂类中的静态方法。

```
// 创建一个固定大小的线程池
ExecutorService executorService = Executors.newFixedThreadPool(5);


// 创建一个单线程池
ExecutorService executorService = Executors.newSingleThreadExecutor();
```

**线程池的作用**

在线程池中，多个任务可以被并发执行，因为线程池能够管理多个线程并行处理任务。

线程池可以重复利用现有线程，避免频繁创建和销毁线程带来的系统开销，尤其适用于短生命周期的任务。

#### 37.

#### 38.

#### 39.

#### 40.
