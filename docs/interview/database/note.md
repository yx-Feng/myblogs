### 1. MySQL事务的四大特性ACID

事务：把一组密不可分的操作集合在一起，这些操作要么全部执行，要么全部不执行。

- 原子性（Atomicity）：事务内定义的操作是一个整体，是不可分割的。  

- 一致性（Consistency）：同一个事务，多次读取数据库中的同一个数据，读取的内容应该是一致的，不变的。  

- 隔离性（Isolation）：不同事务之间相互独立，互不干扰。  

- 持久性（Durability）：事务提交后，事务内的操作对数据库的修改被永久保存在数据库文件中。

### 2. SQL注入攻击

SQL注入（SQL Injection）是一种常见的网络攻击方式，攻击者通过在应用程序的输入字段中注入恶意SQL代码来访问或篡改数据库中的数据。攻击的核心在于将恶意代码拼接到SQL查询中，执行未预期的数据库操作。

- 通过参数化查询避免将用户输入直接拼接到SQL语句中。

- 最小化数据库权限：限制数据库用户权限，确保即使SQL注入成功，数据库损失最小。

### 3. 非关系型数据库

**键值存储**：Redis、 Amazon DynamoDB。

**文档存储**：MongoDB

**图形数据库**：Neo4j

**优点**：

- **可扩展性**：通常很容易通过增加更多的节点来扩展数据库。
- **灵活性**：数据模型更加灵活，可以存储各种结构的数据。
- **性能**：在处理大量数据和高并发请求时，性能通常优于关系型数据库。

### 4. 线程池的工作原理

线程池通过复用固定数量的线程来执行多个任务，避免了频繁创建和销毁线程带来的开销，提高了资源利用率。

**执行流程**：

- 当一个新任务提交到线程池时，首先会判断是否可以使用已有的核心线程执行任务。如果核心线程未满，则创建新的线程来处理任务。
- 当核心线程已满时，任务会被放入任务队列中，等待线程池中空闲的线程来执行。
- 如果任务队列也满了，则会尝试创建新的线程（但总线程数不能超过最大线程数）。
- 如果线程总数已达到最大线程数并且任务队列已满，则根据拒绝策略来处理任务。

### 5. mysql为什么要索引？索引的好处？

MySQL中的索引是一种用于快速定位数据的技术。索引可以显著提高数据库的查询效率，尤其是在处理大型数据集时。

### 6. Mysql 数据库的架构是怎样的

MySQL 数据库的架构是一个层次化的系统结构，通常可以分为三大层：连接层、服务层和存储引擎层。

**连接层**

- **功能**：主要负责客户端连接管理和安全认证。该层接收来自客户端的请求并管理连接、权限验证、会话处理等。
- **连接池**：为了减少频繁的连接开销，MySQL 提供了连接池来复用现有连接。典型的通信协议包括 TCP/IP 协议等。
- **线程管理**：MySQL 为每个客户端连接创建一个线程，这个线程负责处理该连接的所有操作。

**服务层**

- **查询解析**：这一层会对 SQL 查询进行解析、预处理，并生成查询执行计划。包括 SQL 语法解析和语义检查。
- **查询优化**：查询优化器会根据表的结构、索引、统计信息等对查询进行优化，选择最优的执行方案。比如决定是用索引还是全表扫描。
- **缓存和查询结果**：MySQL 可以缓存查询的结果，对于重复查询返回缓存数据，而不需要重新执行查询。
- **事务管理**：MySQL 支持事务，通过事务管理器负责对事务的控制，包括提交、回滚、锁定等操作，以保证数据一致性。
- **权限控制**：在这个层级 MySQL 也会对客户端的权限进行校验，确保用户只能访问被授权的数据。

**存储引擎层**

- **存储引擎接口**：MySQL 的存储引擎层是其架构的核心，存储引擎接口提供了一个抽象层，应用程序可以通过统一接口访问底层存储引擎，具备高扩展性。
- **不同存储引擎**：MySQL 支持多种存储引擎（如 InnoDB、MyISAM、Memory、NDB 等），每个引擎的实现和特点不同，例如：
  - **InnoDB**：默认的事务型存储引擎，支持事务、行级锁以及崩溃恢复机制，适用于高并发、需要事务控制的场景。
  - **MyISAM**：不支持事务，采用表级锁，性能较高但不具备数据一致性保障，适合只读应用场景。
  - **Memory**：数据存储在内存中，速度快，但数据断电后会丢失，适用于临时数据的处理。
- **日志和恢复**：存储引擎还负责具体的数据存储和检索，并通过日志机制提供数据的恢复功能。

### 7. MySQL 索引的数据结构

**索引**是存储引擎用于快速查找数据记录的一种数据结构。

索引的数据结构：B+树。

**二叉查找树**：任何节点的键值，大于左子节点的键值，小于右子节点的键值。

**二叉平衡树**：基于二叉查找树，要求每个节点的左右子树的高度差不超过1。

**B树（Balance Tree）**：基于二叉平衡树，单个节点可以存储多个键值和数据。（考虑到表的数据和索引一般存储在磁盘中，如果使用平衡二叉树作为索引的数据结构，每查找一次数据就需要从磁盘中读取一个节点，如果要存的数据很多，则二叉树的节点就很多，查找数据时磁盘IO就比较多，查询效率低）

**B+树**：对B树的进一步优化，B+树非叶子节点上是不存储数据的，仅存储键值。（因为在数据库中页的大小是固定的，如果不存储数据，那么就会存储更多的键值，相应的树的阶数就会更大，树就会更矮更胖，查找数据进行磁盘的IO次数有会再次减少）

### 8. 脏读 不可重复读 幻读 分别是什么，如何预防

**脏读**：是指一个事务读取到了另一个事务尚未提交的修改。由于该数据是未提交的临时数据，后续可能会被撤销或修改，导致读取数据不一致。

**不可重复读**：不可重复读是指在同一个事务中，两次读取同一数据却得到了不同的结果。这通常是因为在两次读取之间，另一事务修改了该数据并提交了，导致数据发生变化。

**幻读**：指一个事务在两次读取过程中，因另一事务的插入或删除操作，导致第一次读取的数据集与第二次读取的数据集不同。

**预防**

使用锁机制

- **行级锁（Row Lock）**：仅锁定当前操作的行，适合需要高并发且频繁操作的场景，可以防止并发操作导致的数据不一致。

- **表级锁（Table Lock）**：锁定整张表，通常用于批量更新的场景，避免其他事务的并发干扰，但会影响并发性能。

- **共享锁（S Lock）**：允许多个事务并发读，不允许写操作。适合读多写少的场景，防止脏读。

- **排他锁（X Lock）**：排他锁只允许单一事务操作数据，可以防止脏读和不可重复读，但会显著降低并发能力。

MVCC（多版本并发控制）

- 可以通过**保存数据的多个版本**来避免不可重复读和幻读，广泛应用于MySQL InnoDB等数据库引擎。

### 9. MySQL中的事务隔离级别

MySQL 提供了四种事务隔离级别，从低到高分别是：

- 读未提交（Read Uncommitted）：事务可以读取其他事务未提交的数据（脏读）。

- 读已提交（Read Committed）：一个事务只能读取其他事务已提交的数据，避免了脏读，但仍可能出现不可重复读和幻读问题。

- 可重复读（Repeatable Read）（MySQL 默认级别）：保证在一个事务内多次读取同一数据的结果是一样的，即避免了不可重复读问题。

- 可串行化（Serializable）：最高的隔离级别，事务按顺序执行，类似加了全表锁。

### 10. 查询当前数据库的事务隔离级别的命令

查看当前会话（SESSION）事务隔离级别：

```
SELECT @@SESSION.tx_isolation; -- MySQL 5.7 及更早版本
SELECT @@SESSION.transaction_isolation; -- MySQL 8.0 版本
```

查看全局（GLOBAL）事务隔离级别：

```
SELECT @@GLOBAL.tx_isolation; -- MySQL 5.7 及更早版本
SELECT @@GLOBAL.transaction_isolation; -- MySQL 8.0 版本
```

### 11. mysql怎么看索引

要查看某个表的索引，可以使用 `SHOW INDEX` 命令。此命令会返回关于指定表 `table_name` 的所有索引的详细信息，包括索引名称、索引字段、索引类型、唯一性、索引的顺序（列顺序）、索引的唯一性等。

```
SHOW INDEX FROM table_name;
```

你也可以使用 `DESCRIBE` 或 `EXPLAIN` 来查看某个查询是否利用了索引：

```
EXPLAIN SELECT * FROM table_name WHERE a = 1;
```

### 12. (a,b)联合索引

**联合索引**（Composite Index）是指在数据库中，针对多个列的组合创建的索引。它是由多个列的值一起构成索引键值，从而加速基于这些列的查询操作。

联合索引的使用场景：多条件查询和排序查询

- 如果你查询的 `WHERE` 条件或 `ORDER BY` 需要根据 `a` 或 `(a, b)` 来排序，MySQL 就可以高效地利用这个联合索引。

**查询**

MySQL 会首先按照列 `a` 进行索引查询，然后按列 `b` 查询。

如果查询条件只涉及 `b`，MySQL 不能直接利用 `(a, b)` 的联合索引来优化查询，因为索引的设计顺序是首先按 `a` 查询，然后再按 `b` 查询。

```
CREATE INDEX idx_ab ON table_name(a, b);
```

**排序同理**

### 13. 索引失效的场景

**1. 使用 `OR` 条件时，部分索引失效**

```
CREATE INDEX idx_ab ON table_name(a, b);
SELECT * FROM table_name WHERE a = 1 OR b = 2;
```

`a = 1` 可以使用索引，但 `b = 2` 不能直接使用 `(a, b)` 索引，因为索引的顺序是先 `a`，后 `b`，所以 MySQL 会退化为全表扫描。

**2. 在 `ORDER BY` 或 `GROUP BY` 中字段顺序与索引不一致**

在这个查询中，`b` 排序不会使用 `(a, b)` 联合索引，因为索引的顺序是 `(a, b)`，而 `ORDER BY b` 需要按照 `b` 排序。

```
SELECT * FROM table_name ORDER BY b;
```

**3. 在查询中对索引字段做了运算或函数操作**

如果在索引字段上使用了函数、算术运算符或其他操作符，索引通常会失效。因为 MySQL 会先进行运算或函数处理，不能直接利用索引扫描。

```
SELECT * FROM table_name WHERE YEAR(date_column) = 2023;
```

解决方法：避免对索引字段进行函数运算或算术运算。如果需要，可以将表达式外部化，提前计算好。

```
SELECT * FROM table_name WHERE date_column >= '2023-01-01' AND date_column < '2024-01-01';
```

**4. 使用通配符 `%` 开头的 `LIKE` 查询**

当在 `LIKE` 查询中使用通配符 `%` 在字符串开头时，MySQL 无法利用索引。因为 `%` 表示任意字符，索引的前缀匹配特性会失效。

```
SELECT * FROM table_name WHERE name LIKE '%abc';
```

### 14. 延时双删是怎么做的，是否能保证强一致性

**延时双删**是一种常用的缓存一致性保证方案，特别是在 **缓存失效后** 或 **缓存更新时**，避免因为删除缓存和写入数据库之间的时间窗口（race condition），导致数据库和缓存中的数据不一致。

具体流程如下：

1. **第一次删除缓存：** 首先删除缓存中的数据。
2. **写入数据库：** 然后进行数据库更新（例如修改或插入）。
3. **延时操作：** 设置一个短暂的延时，确保缓存删除操作完成且可能的缓存访问请求也完成。
4. **第二次删除缓存：** 在延时操作后再次删除缓存，以确保更新后的数据不会被错误缓存。

**为什么需要延时？**

延时的目的是为了保证在缓存删除和数据库更新的过程中，确保缓存删除操作完成，并且可能存在的请求仍然可以正确访问更新后的数据库数据，而不是再次访问已经被删除的缓存数据。

**不能保证强一致性。**

强一致性：在任何时候，系统中的所有副本的数据都是一致的。

- 在缓存删除后的延时窗口内，可能有请求还会访问缓存，此时可能读取到过期数据，而此时数据库中的数据已经被更新。

- 无法解决高并发问题： 在高并发环境下，可能多个请求同时发出更新操作，虽然双删操作已经做了延时，但并不能完全避免竞争条件。

### 15. 唯一索引、聚簇索引、非聚簇索引的区别

唯一索引是一种逻辑约束，确保索引列中的数据是唯一的。

聚簇索引

- 决定了表中数据的物理存储顺序，并按照索引列排序。一个表只能有一个聚簇索引。

- 优点：对范围查询特别高效，例如查询某一范围的数据（如查找所有年龄在 30 到 40 岁之间的用户）。

- 缺点：插入、删除和更新操作可能会导致数据的重排，影响性能。

非聚簇索引

- 独立于数据表，它存储了数据的索引值以及相应数据的指针（即数据的物理位置），表数据的实际存储顺序与索引顺序无关。一个表可以有多个非聚簇索引。

- 优点：不需要重新排列表中的数据，维护相对较少。

- 缺点：对于需要频繁更新的字段（尤其是索引字段），维护非聚簇索引可能会影响性能。

### 16. mysql和pgsql区别

MySQL 和 PostgreSQL是两种广泛使用的关系型数据库管理系（RDBMS）。

**mysql**

- 对简单查询表现更优（如读密集型场景），部署简单，适合中小型网站。

**PostgreSQL**

- 对复杂查询（如 JOIN、多子查询）性能更优。适合数据分析、科学计算、企业级应用，支持 OLAP和 OLTP。
  
  - OLAP：用于数据分析和决策支持的技术，主要用于处理和分析大量历史数据，如数据仓库通常使用OLAP技术来存储历史数据，并进行报表和数据分析。
  
  - OLTP：用于处理日常事务操作的系统，通常用于执行大量的简短事务，如银行交易系统中账户余额查询、存款、取款等交易操作。

- 支持复杂的数据类型，如数组、JSON、XML 等，并提供了丰富的内置函数和操作符，使得数据处理更加灵活和方便。

### 17. 最左匹配原则

**最左匹配原则（Leftmost Match First）** 是一种在 SQL 查询优化中的规则，尤其在 **OR 连接的条件** 和 **LIKE模糊查询**等场景中使用。

**最左匹配原则**指的是，当 SQL 查询中存在多个查询条件时，数据库查询优化器会首先尝试匹配最左边的条件。

为了提高性能，应确保查询的最左边条件能够利用索引。

```
SELECT * FROM employees 
WHERE department_id = 1 
   OR department_id = 2 
   OR salary > 5000;
```

在进行模糊查询时（例如使用 `LIKE` 关键字），**最左匹配原则**也起作用。

如果查询支持前缀匹配（`LIKE 'abc%'`），则最左匹配原则会自动触发，数据库可以通过索引优化查询性能。前面有通配符 `%`，表示可以匹配任何字符开头。数据库无法预测哪些记录符合条件，因此会进行全表扫描。因而无法利用索引。

### 18. 并发事务问题以及MySQL如何解决

并发事务问题是指多个事务同时访问和操作数据库时，可能引发的一系列数据一致性和完整性问题。

**1. 脏读（Dirty Read）**

一个事务读取了另一个事务未提交的数据。

**2. 不可重复读（Non-Repeatable Read）**

在同一个事务中，多次读取同一数据时，值可能不同。

**3. 幻读（Phantom Read）**

一个事务在读取某一范围的数据时，另一个事务插入或删除了该范围内的数据。当前事务再次读取时，发现了“幻影”数据。

**4. 更新丢失（Lost Update）**

两个事务同时更新同一数据，其中一个事务的更新被覆盖。一方的修改被意外丢弃。

**解决** - **事务的隔离级别** 和 **锁机制**

MySQL提供四种事务隔离级别，通过限制并发事务对数据的可见性来解决问题。

| **隔离级别**             | **脏读** | **不可重复读** | **幻读** | **特性与使用场景**                 |
| -------------------- | ------ | --------- | ------ | --------------------------- |
| **READ UNCOMMITTED** | 可能     | 可能        | 可能     | 最低隔离级别，性能高，但可能导致脏读。         |
| **READ COMMITTED**   | 不可能    | 可能        | 可能     | 解决脏读问题，Oracle默认隔离级别。        |
| **REPEATABLE READ**  | 不可能    | 不可能       | 可能     | MySQL默认隔离级别，使用一致性视图解决不可重复读。 |
| **SERIALIZABLE**     | 不可能    | 不可能       | 不可能    | 最严格隔离级别，通过加锁防止所有并发问题。       |

**MySQL 锁机制**

- 行级锁（Row Lock）：仅锁定当前操作的行，适合需要高并发且频繁操作的场景，可以防止并发操作导致的数据不一致。

- 表级锁（Table Lock）：锁定整张表，通常用于批量更新的场景，避免其他事务的并发干扰，但会影响并发性能。

- 共享锁（S Lock）：允许多个事务并发读，不允许写操作。适合读多写少的场景，防止脏读。

- 排他锁（X Lock）：排他锁只允许单一事务操作数据，可以防止脏读和不可重复读，但会显著降低并发能力。

### 19. 有一个用户表，其中属性有用户唯一Id，用户性别，查询条件这两个属性都需要用到，联合索引应该怎么设置。

联合索引的顺序要根据查询条件的使用频率来决定。如果查询大多数情况下是根据 `userId` 和 `gender` 这两个字段同时筛选的，索引顺序可以设置为 `(userId, gender)`。

```
CREATE INDEX idx_user_id_gender ON user (userId, gender);
```

这个查询将会有效地使用 `idx_user_id_gender` 索引。

```
SELECT * FROM user WHERE userId = 123 AND gender = 'M';
SELECT * FROM user WHERE userId = 123;
```

这个查询在某些情况下可能不会充分利用联合索引，而是根据 `gender` 字段单独创建索引会更有效。

```
SELECT * FROM user WHERE gender = 'M';
```

### 20. 慢sql优化

通常是在数据库执行时间过长的查询或大规模查询时，采取的一系列措施。

- 使用合适的索引，可以显著提高查询性能，尽量避免全表扫描
  
  - 当多个字段一起参与查询时，复合索引比单列索引更高效。
  
  - 避免在索引列上使用函数，在索引列上使用函数会使索引失效，导致全表扫描。
  
  - 避免过多索引：在插入、删除、更新操作时，需要重构索引，过多索引会影响性能。

- 查询语句优化
  
  - 只查询需要的字段，避免使用 `SELECT *`。
  - 避免复杂的子查询：在一些情况下，子查询可以通过 `JOIN` 操作来替代，通常 `JOIN` 性能比子查询更优。例如，`SELECT * FROM A WHERE id IN (SELECT id FROM B)` 可以改写为 `SELECT A.* FROM A JOIN B ON A.id = B.id`，从而提高性能。

- 表分区
  
  - 当表数据量非常大时，可以考虑使用表分区。通过按某些列（如日期、地理区域等）分区，将大表拆分为多个较小的物理表，从而减少查询时的扫描范围，提高查询性能。

### 21. innodb有哪些日志

InnoDB 是 MySQL 默认的存储引擎

- **Redo Log - 重做日志**：保证数据的**持久性**，用于崩溃恢复。在事务提交后，InnoDB 会将对数据的更改记录到重做日志中，即使数据还没有真正写入磁盘。当系统崩溃后，可以通过重做日志恢复尚未写入磁盘的数据。

- **Undo Log - 撤销日志**：用于支持**事务回滚**和**MVCC（多版本并发控制）**。当事务修改数据时，InnoDB 会将旧版本的数据保存在撤销日志中。如果事务被回滚，可以通过撤销日志恢复原来的数据版本。同时，撤销日志也用于实现 MVCC，使得其他事务可以读取事务修改之前的数据版本。

- **bin log - 二进制日志**：记录所有对数据库产生变更的 SQL 语句，主要用于数据库恢复（恢复到某个时间点）和主从复制（将主数据库的更改复制到从数据库）。
