## 1. 进程管理

### 1.1 进程 vs 线程 vs 协程

**进程**：进程是操作系统分配资源的最小单位，拥有独立的内存空间，不同进程间隔离。

**线程**：线程是CPU调度的最小单位，是进程中的一个执行单元，多个线程共享一个进程的内存空间，但调度独立，保留自己的堆栈和寄存器等上下文信息。线程之间的切换由操作系统负责。

一个进程中可以同时存在多个线程，各个线程之间可以并发执行，线程的创建时间比进程快（因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们）。

**协程**：协程是用户空间的“轻量线程”，由程序员控制切换。

### 1.2 生产者-消费者问题

这是一个著名的**进程同步**问题。

**进程同步**：多个进程在执行的时候，它们要按照一定的规则共享系统资源，这种进程间的相互制约关系就是进程同步机制。

**问题描述**

生产者进程：生产产品  

消费者进程：消费产品  

两者之间设置了个缓冲池(含有n个缓冲区)  

生产者生产完，把产品放进一个缓冲区里，消费者消费，就从一个缓冲区中取走产品  

**两个进程必须同步**：不允许消费者进程从一个空缓冲区中取产品，也不允许生产者进程向一个已经满了的缓冲区投放产品

**分析**：

我们定义一些变量：  

- 缓冲池：**buffer[n]**  

- 投入一个产品：数组单元指针**in**加1，表示成**in=(in+1)%n**，含义是暂存产品数量加1  

- 取走一个产品：数组单元指针**out**加1，表示成**out=(out+1)%n**，含义是空闲单元数量加1  

- 对n取余是因为缓冲池里的缓冲区是循环组成的。  

- 变量**counter** => 投放产品：counter+1，取走产品：counter-1

**初始化**：  

int in=0,out=0,counter=0;  

item buffer[n]  

以上变量生产者进程和消费者进程共有

用生产者进程的局部变量**nextp**暂时存放刚刚生产出来的产品。  
用消费者进程的局部变量**nextc**暂时存放每次要消费的产品。

```
void producer(){
    while(1){
        produce an item in nextp;
        ...
        while(counter==n)
        ;
        buffer[in]=nextp;
        in=(in+1)%n;
        counter++;
    }
};
void consumer(){
    while(1){
        while(counter==0)
        ;
        nextc=buffer[out];
        out=(out+1)%n;
        counter--;
        consume the item in nextc;
        ...
    }
};
```

但是这两个程序在并发执行会出现错误，**问题在于**这两个进程共享变量counter  

counter的加1和减1操作我们这样描述：  

register1=counter; register2=counter;  
register1=register1+1; register2=register2-1;  
counter=register1; counter=register2;  

这六个语句的执行顺序如果发生改变，得到的最后的counter的值可能不同。  

**解决**：把变量counter作为临界资源，生产者进程和消费者进程互斥地访问 counter

**用java写个生产者和消费者模型**

实际上需要一个缓冲区，但是本例只设了一个共享整数

```
package thread_test;

//消费者
class Consumer extends Thread {
    private ShareArea sharedObject;

    public Consumer(ShareArea shared) {
        sharedObject = shared;
    }

    public void run() {
        int value;
        do {
            try {
                Thread.sleep((int)(Math.random()*3000));
            }catch(InterruptedException exception){}
            value = sharedObject.getSharedInt();    //获取共享整数的值
            System.out.println("消费："+ value);
        }while(value != 10);
    }
}

//生产者
class Producer extends Thread {
    private ShareArea sharedObject;

    public Producer(ShareArea shared) {
        sharedObject = shared;
    }

    public void run() {
        for(int cnt = 1;cnt <=10 ;cnt++) {
            try {
                Thread.sleep((int)(Math.random()*2000));
            }catch(InterruptedException exception){}
            sharedObject.setSharedInt(cnt);//更改共享数据
            System.out.println("生产:" + cnt);
        }
    }
}

//共享数据访问程序
class ShareArea {
    private int sharedInt = -1;        //共享整数
    private boolean writable = true;//条件变量

    public synchronized void setSharedInt(int value) {
        while(! writable) {
            try {
                wait();                //轮不到生产者写就等待
            }catch(InterruptedException exception) {}
        }
        sharedInt = value;            //生产者写入一个值
        writable = false;           //消费者操作前，生产者不能写入另一个值
        notify();                    //唤醒等待资源的线程
    }

    public synchronized int getSharedInt() {
        while(writable) {
            try {
                wait();                //没轮到消费者就等待
            }catch(InterruptedException exception) {}
        }
        writable = true;            //生产者要等生产者再生产才能消费另一个值
        notify();                    //唤醒等待资源的线程
        return sharedInt;            //消费者得到数据
    }
}

public class SharedTest {
    public static void main(String args[]) {
        ShareArea shareObject = new ShareArea();
        Producer p =new Producer(shareObject);
        Consumer c =new Consumer(shareObject);
        p.start();c.start();
    }    
}
```

### 1.3 生产者和消费者，你会用什么同步机制

在生产者-消费者模型中，生产者负责生产数据，而消费者负责处理数据。由于生产者和消费者可能在不同的线程或进程中执行，因此需要使用同步机制来确保数据安全地在它们之间传递。

**① 阻塞队列（Blocking Queue）**

生产者在队列满时阻塞，消费者在队列为空时阻塞。

**② 信号量（Semaphore）**

信号量是一个计数器，用于控制访问特定资源的线程数量。

- 对于生产者-消费者问题，可以使用两个信号量：一个用于计数可用的缓冲区位置（空位计数），一个用于计数已填充的缓冲区数据（满位计数）。
- 生产者在添加数据前减少空位计数，消费者在取出数据前减少满位计数，从而协调生产和消费的速度。

**③ 互斥锁 + 条件变量**

通过锁保护共享资源，确保同一时刻只有一个线程可以访问共享资源。

条件变量允许线程在特定条件满足时通知其他线程继续工作。生产者会通知消费者数据已经准备好，消费者会等待该通知，反之亦然。

### 1.4 死锁

在多线程编程中，我们为了防止多线程竞争共享资源而导致数据错乱，都会在操作共享资源之前加上互斥锁，只有成功获得到锁的线程，才能操作共享资源，获取不到锁的线程就只能等待，直到锁被释放。

**死锁**：是指两个或两个以上的进程在执行过程中，由于竞争资源而造成的一种阻塞的现象。  

比如说两个进程P1和P2，P1占有资源R1，P2占有资源R2，现在P1想要资源R2，P1想要资源R1，它们都希望对方释放资源，但是它们现在因为没有获得对方的资源，所以无法继续运行，无法释放自己占有的资源，从而陷入了僵持状态。

死锁只有**同时满足**以下四个条件才会发生：

- 互斥条件：多个线程不能同时使用同一个资源。
- 持有并等待条件：当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是等待的同时并不会释放自己已经持有的资源 1。
- 不可剥夺条件：当线程已经持有了资源 ，在自己使用完之前不能被其他线程获取。
- 环路等待条件：在死锁发生的时候，两个或多个线程获取资源的顺序构成了环形链。

## 2. linux操作系统

### 2.1 linux操作系统和window操作系统

**1. 内核架构**：

- Linux：是monolithic（单体）内核，也就是说，Linux 内核将操作系统的所有核心功能（如文件管理、内存管理、硬件抽象等）都集中在一个大的内核空间中运行。

- Windows：混合内核（Hybrid Kernel），Windows 的内核将一些操作系统的功能分散在内核态和用户态之间，以确保系统的稳定性和效率。（内核态：也叫特权模式，在这个模式下，程序可以执行任何 CPU 指令，并直接访问系统的硬件资源。）（用户态：也叫非特权模式，程序运行时不具有访问硬件的权限，需要通过系统调用system call与内核进行交互）

**2. 文件系统**

- Linux：使用统一的层次化目录结构，所有的磁盘分区、外部设备和文件都挂载到这个根目录/下的某个目录中。

- Windows：使用盘符管理，不同的磁盘和分区之间没有统一的目录结构，文件结构更加直观，但不适合复杂的多设备管理。（假设你有 C:、D: 和 E: 这三个磁盘。后来添加了一个新的磁盘，系统会自动为它分配一个盘符，比如 F:。如果你拔掉某个盘并重新连接，Windows 可能会重新分配盘符，当程序依赖于固定的盘符时，这可能会导致程序路径错误）

**3. 命令行界面（CLI）**

- Linux：Linux 的命令行界面非常强大，几乎所有的操作都可以通过命令行完成。常用的 shell 包括 Bash、Zsh、Fish 等。

- Windows ：也提供命令行界面（CMD 和 PowerShell），但是这些工具功能和灵活性远不及 Linux 的命令行。Windows 主要依赖于图形界面进行操作。

### 2.2 chmod指令

```
chmod [选项] 模式 文件名
```

用于改变文件或目录的访问权限。

常见选项-R，表示递归地修改指定目录下的所有文件和子目录的权限。

**数字模式**：三个数字，分别对应 文件所有者（user）、所属组（group）和其他用户（others）的权限。每个数字看成三位二进制，分别对应读权限、写权限和执行权限。

```
chmod -R 755 mydir
```

**符号模式**：用字母和符号来表示权限。

- 用户类别：u（文件所有者）、g（所属组）、o（其它用户）、a（所有用户）。

- 操作符：+（添加权限）、-（移除权限）、=（设置权限）。

- 权限字符：r（读权限）、w（写权限）、x（执行权限）。

```
chmod u+w test.txt
```

### 2.3 硬链接 和 软链接

**①硬链接**（Hard Link）是一个文件的多个引用，指向同一个inode（索引节点），inode用于存储文件元信息（如文件大小、创建时间、权限等）。多个硬链接实际上共享同一个物理文件数据，只是文件名不同。

```
ln 源文件 硬链接文件
```

使用场景：数据备份、版本控制

**②软链接**（Soft Link，也称为符号链接，Symbolic Link）包含的是另一个文件或目录的路径名，当访问软链接时，系统会自动将其解析为指向的源文件或目录。

```
ln -s 源文件或目录 软链接文件
```

软链接是一个独立的文件，有自己的 inode，它只存储源文件或目录的路径信息，不存储实际的数据。

使用场景：方便访问（当源文件或目录的路径较长或复杂时，可以创建软链接，使用较短的名称来访问）、软件升级（在软件升级时，可以通过修改软链接指向新的软件版本，而不需要修改其他依赖该软件的配置文件）。

## 3. IO调度

### 3.1 SPOOLing 技术

一种通过**磁盘等高速存储设备**模拟脱机输入 / 输出操作的技术，用于解决**低速外部设备**与**高速 CPU**之间的速度不匹配问题，实现多任务对独占设备的共享访问。

**核心原理**

虚拟设备抽象：将物理设备（如打印机、磁带机）通过**磁盘缓冲区**虚拟化为多个逻辑设备，允许多个进程同时 “独占” 同一物理设备（实际为分时复用）。

脱机操作模拟：

- 输入阶段：将输入数据预先读入磁盘的 “输入井”，避免 CPU 等待低速输入设备。

- 输出阶段：将输出数据暂存磁盘的 “输出井”，由系统统一调度设备输出，减少 CPU 等待时间。

**系统组成**：

- 输入井/输出井：磁盘上的存储空间，分别模拟脱机输入/输出的磁盘。

- 输入缓冲区：内存区域，暂存从输入设备读取的数据，再批量写入输入井。

- 输出缓冲区：内存区域，暂存从输出井读取的数据，再批量发送到输出设备。

- SPOOLING管理程序：控制输入/输出井的读写，协调进程与物理设备的交互。

**应用场景**：

- 共享打印机：多个进程请求打印时，输出数据先存入输出井，由SPOOLing程序按优先级或顺序打印。

## 4. 同步/异步

### 4.1 什么是同步和异步

同步指的是一个任务在执行时，必须等待前一个任务完成之后才能继续。执行顺序是“排队式”的。

异步指的是一个任务在执行时，不需要等待前一个任务完成，可以先去做别的事，等结果好了再回来处理。

## 5. I/O多路复用

在传统阻塞I/O中，每个I/O操作都需要独占一个线程等待数据的到来。而**I/O多路复用**通过内核提供的机制，让一个线程能够同时监听多个I/O事件，当其中的某一个或多个通道就绪时，线程会被唤醒来处理这些事件。

**优势**

- 高并发： 一个线程可以同时处理多个I/O通道，不需要为每个通道创建独立线程，节省资源。

- 低资源占用：减少了线程切换和上下文切换的开销，提高了系统效率。

- 非阻塞：通过异步事件通知，避免线程在等待I/O时被阻塞。

## 6. 操作系统内存的设计可借鉴之处

1. 虚拟内存：操作系统通过虚拟内存机制使程序能够使用超出物理内存的空间。在分布式系统中，可以通过类似虚拟内存的抽象，让应用程序认为其拥有大量资源，而实际的物理资源则由系统进行智能调度。这可以提升资源利用率，避免资源不足导致的应用崩溃。

2. 内存缓存：操作系统通常会缓存常用数据或代码，以提高系统的响应速度和性能。在分布式系统中，可以使用类似的缓存机制（如 Redis）来加速数据访问，减少数据库或磁盘的访问压力。

3. 自动内存管理：操作系统采用垃圾回收机制自动管理内存的分配与释放，减少内存泄漏的风险。

## 7. Linux内核的功能有哪些

**进程管理**：负责进程的创建（如`fork`）和终止（如`exit`），并管理进程的生命周期。Linux内核通过调度算法（如完全公平调度器CFS）决定哪些进程获得CPU时间。还支持进程间通信（IPC）如管道、消息队列、共享内存等。

**内存管理**：内核负责管理**物理内存**和**虚拟内存**的分配、回收。内核支持**交换空间**（swap），当物理内存不足时，可以将部分内存数据写入硬盘上的交换分区，腾出内存给其他进程。

**文件系统管理**：提供文件的创建、删除、读取、写入等基本操作，同时支持目录结构管理和文件权限控制。

**硬件设备管理**：Linux内核通过设备驱动与硬件交互，支持各类硬件设备如磁盘、网络适配器、显卡、声卡等。

**网络管理**：Linux内核实现了TCP/IP协议栈，支持多种网络协议（如TCP、UDP、IP、ICMP等），提供数据传输、路由、连接管理等功能。防火墙。
